# 以太坊虚拟机

## 总览

以太坊虚拟机或者EVM是以太坊中智能合约的运行时环境。它不仅是沙箱也是一个真实的完整被隔离的环境，这意味着他的代码在EVM内运行时，不会访问网络，文件系统或其他的进程。智能合约甚至可以被限制不能访问其他智能合约。

## 账户

以太坊有两类账户它们共享同一个地址空间：由秘钥对控制的外部账户，由与账户一起存储的代码控制的合约账户。

外部账户的地址由公钥决定，而合约的地址在合约创建时确定。(它源自于创建者的地址和从这个地址发送的交易的数额，也就是所谓的“随机数”)。

无论账户是否存储代码，EVM都会平等的对待这两种类型的地址。

每个账户有一个叫做存储的持久的键值对存放256位字到256位字的映射。

此外，每个账户都有一个以太币余额(准确的说是“Wei”，1个以太币=10^18wei)，可以通过发送包含以太币的交易来修改。

## 交易

一笔交易就是一条消息。它从一个账户发送到另一个账户(它可能是相同的或者空的，见下文)。它可以包含二进制数据（所谓的“有效负载”）和以太币。

如果目标账户包含代码，则执行这段代码并且有效负载像输入数据提供。

如果没有设置目标账户(这笔交易没有收款人，或者收款人被设置成```null```),这笔交易创建一笔新合约。如前所述，这笔合约的地址不是0地址，而是从发送者和这笔交易发送的数额(“随机数”)中派生的地址。这种合约创建交易的有效载荷被视为EVM字节码并被执行。执行的结果(输出数据)作为合约的代码被永久存储。这意味着为了创建合约，你不用发送合约的实际代码，而是发送实际执行时返回该代码的代码。

<div style="background:#76afdb;color:#fff;padding:5px;font-weight:600">
⚠️ Note
</div>
<div style="background:#e9f2fa;color:#404040;padding:10px">
在创建合约时，他的代码还是空的。因此，在构造函数执行完成之前，你不应该在回调正在构造构建的合约。
</div>

<br/>

## Gas （手续费）

创建时，每一笔交易会产生一定数量的gas(手续费)，这笔交易的发起者(```tx.origin```)必须支付这笔费用。 当EVM执行这笔合约的时候，gas会根据特定的规则被逐渐消耗掉。 如果这笔gas在任何时候被用完了，会触发一个out-of-gas的异常，这会终止执行并退回对当前调用帧中状态所做的修改。


这种机制激励了EVM执行时间的经济使用，并且还补偿了EVM执行者(矿工/质押者)工作的报酬。由于每个块都有个最大的gas数量，这个数量也限制了验证块所需的工作数量。

gas的单价是一个被交易发起人设置的值，他必须预先向EVM执行者支付gas单价*gas数量的费用。如果执行后还剩下一下gas，它将被退回给交易的发起人。如果发生恢复更改的异常，用完的gas不会被退回。

由于EVM执行者可以选择是否包含一笔交易，所以交易的发起人不能通过设置一个低gas单价来滥用系统。


### 存储、内存和堆栈

以太坊虚拟机有3个可以存储数据的区域：存储、内存和堆栈。

每个账户有一个被称为存储的数据区域，它在函数调用和交易之间是持久的。存储是一个256位字到256位字映射的键值对。无法从一个和合约中枚举存储，读取成本相对较高，初始化存储和修改存储的成本更高。由于这些成本，你应该让你保存在持久化存储最小化为合约所需要执行的内容。在合约之外存储衍生计算、缓存和聚合等数据。一个可约可以既不读也不写除自己之外的任何存储。

第二个数据区域叫内存，合约每次调用消息，都会获得一个新清除的实例。内存是线性的，它可以在字节级别上寻址，但读取宽度限制为256，而写入可以是8~256位宽。当访问(读或写)一个之前不存在的内存字时，内存会扩展一个256位的字。扩展的时候，必须支付gas费用。内存增长的越大，成本越高。（他是指数级增长的）。

EVM不是寄存器机，却是一个在堆栈机，因此，所有所有计算都在称为堆栈的数据区上执行。它有最大大小为1024个元素，包含256位的字。通过以下方式访问堆栈仅限于顶端：可以将最顶部的16个元素之一复制到堆栈顶部，或者将最顶部的元素与他下面的16个元素之一交换。其他所有的操作都从堆栈中取出最顶部的两个(或者一个，或者更多，取决于操作)元素，并把结果压入堆栈顶部。当然，可以把堆栈元素移动到存储或内存中以便访问堆栈的更深处，但在没有移除堆栈顶部元素的时候，不可能仅访问更深处的元素。

### 指令集

EVM保持最小化的指令集，以便于避免可能导致共识问题的不正确的和不一致的实现。所有指令都对基础数据类型256位字或内存片(或其他字节数组)进行操作。存在通常的算数，比特，逻辑和比较操作。可以进行有条件和无条件跳转。此外，合约可以访问与当前块相关的属性，例如编号和时间戳。

获得一个完整的列表，参见作为汇编文档一部分的[操作码列表](./Opcodes.md)。

### 消息调用

合约通过消息调用的方式调用其他合约或者向非合约的账户发送以太币。消息调用和交易非常相似，它一样有一个源、一个目标、数据负载、以太币、gas和返回数据。实际上，每一笔交易都包含一个顶级的消息调用，而这个消息有可以创造更多的消息调用。

合约可以决定应该通过内部消息调用发送多少剩余的gas，以及它想要保留多少。如果在内部调用时(或任何其他异常)发生gas不足意外，这将通过放入堆栈的错误值发出信号。这种情况下，只有与调用一起发送的gas才会被用完。在Solidity中，调用合约在这种场景中会导致一个手动异常，因此异常会“冒泡”调用堆栈。

如上所述，被调用的合约(可以与调用者一样)会收到一个新清空的内存实例，并且访问调用负载——这将在成为calldata的单独区域中提供。完成执行后，会返回数据。数据被调用者存在一个调用者预分配的内存区域里。所有这些都是完全同步的。


调用被限制在1024的深度，这意味着更多的复杂操作，循环应该优先采用递归方式调用。此外，消息调用中智能转发63/64的gas，这会导致实际深度限制比1000稍微少一点。


### 委托调用库

消息调用中存在一个特殊的变种，委托调用。它与消息调用相同，除了目标地址的代码是在带哦用合同上下文(即地址)中执行，并且msg.sender和msg.value不更改其值。

这意味着，一份合约可以在运行时，从一个不同的地址动态加载代码。存储，当前地址和余额仍然是调用合，只是代码取自被调用地址。

这使得在Solidity实现库功能成为可能：重用库代码快应用到合约的存储，例如为了实现一个复杂的数据结构。

### 日志

可以用一种特殊的可索引形数据结构存储数据，它一直映射到块的级别。在Solidity里这个功能通常被叫做日志，用它来实现[事件](./Event.md)。日志数据生成之后合约就不能访问它了，但是他们可以从区块链之外被有效的访问。由于部分日志数据存储在bloom过滤器中，因此可以以一种高效且加密安全的方式搜索这些数据，因此不下载整个区块链的网络对等方(所谓的“轻客户端”)仍然可以找到这些日志。

### 创建

合约可以甚至可以使用一个特殊的操作代码创建其他合约(例如：它们不会像交易那样简单的调用0地址)创建调用和普通消息调用唯一的区别就是，执行负载数据并将结果存储为代码，调用者/创建者接收堆栈上新合约的地址。


### 停用和自毁

只有一种方式可以从区块链中删除代码，该地址的合约执行自毁操作。这个地址上存储的剩余以太币会发送到一个被设计好的目标，然后从状态中移除存储和代码。从理论上说删除合约像是一个好主意，但是这种操作有潜在的危险，就像有人把以太币发送给移除合约一样，以太币将永远丢失。


<div style="background:#e9b684;color:#fff;padding:5px;font-weight:600;">
⚠️ Waring
</div>
<div style="background:#fdeecf;color:#404040;padding:10px">
即使一个合约通过```自毁```方式删除,它仍旧是区块链历史记录中的一部分并且可能被更多的以太坊节点所保留。所以使用```自毁```和在硬盘上删除数据的效果不一样。
</div>

<br/>

<div style="background:#76afdb;color:#fff;padding:5px;font-weight:600">
⚠️ Note
</div>
<div style="background:#e9f2fa;color:#404040;padding:10px">
即使一个合约的代码不包含```自毁```调用，他也可以```托管调用（delegatecall）```或```调用代码（callcode）```执行这个操作。
</div>

<br/>

如果您想停用合同，则应通过更改某些内部状态来禁用它们，从而导致所有功能恢复。这可以让合约无法使用，以为它会立刻返回以太币。

### 预编译合约

有一个小段特殊合约地址：这个地址范围在1(包括1)到8之间的地址范围包含“预编译合约”，可以像任何其他合约一样调用，但它们的行为(它们的gas消耗)没有被EVM代码定义存储在该地址（它们不包含代码），而是在EVM执行环境本身中实现。

不同的EVM-兼容链可能使用一份不同的预编译合约。新的预编译合未来也可能加入到以太坊的主链，但是你可以合理期望，他们总是在1到0xffff(包含)之间的范围内。